#config PLATFORM CPU_MPMD
#config PROCESSES 4
#config CORES 8
#config MODE debug

const int dimA = 16;
const int dimM = 4;

struct Complex{
	float real;
	float imaginary;
};

array<Complex,dimA,dist> ad1;
array<Complex,dimA,dist> ad2;
array<Complex,dimA,dist> adr;
array<Complex,dimA,copy> ac1;
array<Complex,dimA,copy> ac2;
array<Complex,dimA,copy> acr;

matrix<Complex,dimM,dimM,dist> md1;
matrix<Complex,dimM,dimM,dist> md2;
matrix<Complex,dimM,dimM,dist> mdr;
matrix<Complex,dimM,dimM,copy> mc1;
matrix<Complex,dimM,dimM,copy> mc2;
matrix<Complex,dimM,dimM,copy> mcr;


Complex init1(Complex x){
	x.real = (float) 42;
	x.imaginary = (float) 21;
	return x;
}

Complex init2(Complex x){
	x.real = (float) 17;
	x.imaginary = (float) 13;
	return x;
}

Complex initIndexA1(int i, Complex x){
	x.real = (float) i;
	x.imaginary = (float) i / 2.0f;
	return x;
}

Complex initIndexA2(int i, Complex x){
	x.real = (float) i;
	x.imaginary = (float) i / 2.0f;
	return x;
}


Complex initIndexM1(int r, int c, Complex x){
	x.real = (float) r;
	x.imaginary = (float) c;
	return x;
}

Complex initIndexM2(int r, int c, Complex x){
	x.real = (float) r;
	x.imaginary = (float) c;
	return x;
}

Complex sumComplex(Complex y, Complex x){
	Complex result;
	result.real = x.real + y.real;
	result.imaginary = x.imaginary + y.imaginary;
	return result;
}

Complex plusIndexA(int i, Complex x){
	Complex result;
	result.real = x.real + i;
	result.imaginary = x.imaginary + i / 2;
	return result;
}

Complex plusIndexM(int r, int c, Complex x){
	Complex result;
	result.real = x.real + r;
	result.imaginary = x.imaginary + c;
	return result;
}

Complex timesY(float y, Complex x){
	Complex result;
	result.real = x.real * y;
	result.imaginary = x.imaginary * y;
	return result;
}



// should test: zip, zipInPlace, zipIndex, zipLocalIndex, zipIndexInPlace, zipLocalIndexInPlace
// for matrix and array, dist and copy

main{

// init
//	cs1.mapIndexInPlace(init1());
//	cs2.mapIndexInPlace(init2());
//	cs1.show();
//	cs2.show();
	
// zip
//	rcs = cs1.zip(cs2, sumComplex());
	
// result
//	rcs.show();



// initial 
mkt::print("Inital:\n");
ad1.mapIndexInPlace(initIndexA1());
ad2.mapIndexInPlace(initIndexA2());
ac1.mapIndexInPlace(initIndexA1());
ac2.mapIndexInPlace(initIndexA2());
md1.mapIndexInPlace(initIndexM1());
md2.mapIndexInPlace(initIndexM2());
mc1.mapIndexInPlace(initIndexM1());
mc2.mapIndexInPlace(initIndexM2());
ad1.show();
ac1.show();
md1.show();
mc1.show();

// zip
mkt::print("Zip; expected result: sum.\n");
adr = ad1.zip(ad2, sumComplex());
acr = ac1.zip(ac2, sumComplex());
mdr = md1.zip(md2, sumComplex());
mcr = mc1.zip(mc2, sumComplex());

adr.show();
acr.show();
mdr.show();
mcr.show();

// map
/*mkt::print("Map:\n");
adr = ad.map(timesY(2.0f));
acr = ac.map(timesY(2.0f));
mdr = md.map(timesY(2.0f));
mcr = mc.map(timesY(2.0f));

adr.show();
acr.show();
mdr.show();
mcr.show();


// mapIndexInPlace
mkt::print("MapIndexInPlace:\n");
ad.mapIndexInPlace(initIndexA());
ac.mapIndexInPlace(initIndexA());
md.mapIndexInPlace(initIndexM());
mc.mapIndexInPlace(initIndexM());

ad.show();
ac.show();
md.show();
mc.show();

// mapIndex
mkt::print("MapIndex:\n");
adr = ad.mapIndex(plusIndexA());
acr = ac.mapIndex(plusIndexA());
mdr = md.mapIndex(plusIndexM());
mcr = mc.mapIndex(plusIndexM());

adr.show();
acr.show();
mdr.show();
mcr.show();

// mapLocalIndexInPlace
mkt::print("MapLocalIndexInPlace:\n");
ad.mapLocalIndexInPlace(initIndexA());
ac.mapLocalIndexInPlace(initIndexA());
md.mapLocalIndexInPlace(initIndexM());
mc.mapLocalIndexInPlace(initIndexM());

ad.show();
ac.show();
md.show();
mc.show();

// mapLocalIndex
mkt::print("MapLocalIndex:\n");
adr = ad.mapLocalIndex(plusIndexA());
acr = ac.mapLocalIndex(plusIndexA());
mdr = md.mapLocalIndex(plusIndexM());
mcr = mc.mapLocalIndex(plusIndexM());

adr.show();
acr.show();
mdr.show();
mcr.show();
*/

}
