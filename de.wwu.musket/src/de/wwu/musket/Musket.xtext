grammar de.wwu.musket.Musket with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate musket "http://www.wwu.de/musket/Musket"

Model:
	config=ConfigBlock
	data+=Data*
	functions+=Function*
	logic=LogicBlock
;

//-----------------------------------------------------------
ConfigBlock:
	('#config' 'PLATFORM' (platformCPU?='CPU' & platformGPU?='GPU')) &
	('#config' 'PROCESSES' processes=INT)
;

//-----------------------------------------------------------	
Data:
	Array | Global | Const;

Array:
	{IntArray} 'int' var=Variable '[' size=INT ']' ('=' '{' values+=INT (',' values+=INT)* '}')? ';' |
	{DoubleArray} 'double' var=Variable '[' size=INT ']' ('=' '{' values+=DOUBLE (',' values+=DOUBLE)* '}')? ';' | 
	{BoolArray} 'bool' var=Variable '[' size=BOOL ']' ('=' '{' values+=BOOL (',' values+=BOOL)* '}')? ';'
;

Variable:
	name=ID
;

Global:
	{IntGlobal} 'int' var=Variable '=' value=INT ';' |
	{DoubleGlobal} 'double' var=Variable '=' value=DOUBLE ';' | 
	{BoolGlobal} 'bool' var=Variable '=' values=BOOL ';'
;

Const:
	{IntConst} 'const' 'int' var=Variable '=' value=INT ';' |
	{DoubleConst} 'const' 'double' var=Variable '=' value=DOUBLE ';' | 
	{BoolConst} 'const' 'bool' var=Variable '=' values=BOOL ';'
;
	
//-----------------------------------------------------------
Function:
	returnType=Type name=ID '(' (params+=ParameterDef (',' params+=ParameterDef)*)? ')' '{'
		(statement+=Statement ';')*
	'}'
;
	
ParameterDef:
	type=Type var=Variable
;
	
//-----------------------------------------------------------
LogicBlock:
	'main' '{' content+=Logic+ '}'
;

Logic:
	ControlStructure | MusketStatement;
	
ControlStructure:
	ForLoop | IfClause;
	
ForLoop:
	ConditionalForLoop | IteratorForLoop
;

ConditionalForLoop:
	{ConditionalForLoop} 
	'for' '(' (init=Assignment)? ';' (condition=CompareExpression)? ';' (increment=ArithmeticExpression)? ')'
	//TODO break/continue 
	( '{' statements+=MusketStatement* '}' | => statements+=MusketStatement?)
;

IteratorForLoop:
	'for' '(' iter=ParameterDef ':' dataStructure=[Variable] ')'
	//TODO break/continue
	( '{' statements+=MusketStatement+ '}' | => statements+=MusketStatement?)
;

IfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=MusketStatement+
	'}'
;

MusketStatement:
	{MusketStatement} (var=[Variable] '=')? (obj=[Variable] '.')? function=Skeleton '(' param=Parameter ')' ';' |
	Assignment ';'
;

Parameter:
	FunctionCall |
	VariableRef |
	IntVal |
	DoubleVal |
	BoolVal
;

Statement:
	Assignment |
	ReturnStatement |
	VariableDef |
	FunctionCall
;

Assignment:
	{VariableAssignment} var=[Variable] '=' value=Expression |
	{IncrementAssignment} var=[Variable] '+=' value=Expression |
	{DecrementAssignment} var=[Variable] '-=' value=Expression |
	{MultiplyAssignment} var=[Variable] '*=' value=Expression |
	{DivideAssignment} var=[Variable] '/=' value=Expression
;

VariableDef:
	type=Type var=Variable ('=' initValue=Expression)?
;

ReturnStatement:
	'return' Expression
;

FunctionCall:
	{InternalFunctionCall} value=[Function] '(' params+=Parameter (',' params+=Parameter)* ')' |
	{ExternalFunctionCall} namespace=ID '::' function=ID '(' params+=Parameter (',' params+=Parameter)* ')'
;

// Expression tree
Expression:
	CompareExpression // any boolean or arithmetic expression 
;

// Boolean expressions
CompareExpression returns Expression: // Top-level boolean expression
	Condition {CompareExpression.eqLeft=current} (op = BooleanOperator eqRight = Condition)?
;

Condition returns Expression:
	Or
;

Or returns Expression:
	And ({Or.leftExpression=current} OP_CONDITION_OR rightExpression=And)*
;

And returns Expression:
	BooleanExpression ({And.leftExpression=current} OP_CONDITION_AND rightExpression=BooleanExpression)*
;

BooleanExpression returns Expression:
	{Not} OP_CONDITION_NOT expression = BooleanExpression |
	BoolVal |
	AdditionSubtraction
;

// Arithmetic expressions
AdditionSubtraction returns Expression: // Top-Level arithmetic expression
	=> MultiplicationDivision ({Addition.left=current} OP_MATH_PLUS right=MultiplicationDivision)* |
	MultiplicationDivision ({Subtraction.left=current} OP_MATH_MINUS right=MultiplicationDivision)*
;

MultiplicationDivision returns Expression:
	=> PrefixedExpression ({Multiplication.left=current} OP_MATH_MULT right=PrefixedExpression)* |
	PrefixedExpression ({Division.left=current} OP_MATH_DIV right=PrefixedExpression)*
;

PrefixedExpression returns Expression:
	{SignedArithmetic} '-' expression=ArithmeticExpression |
	ArithmeticExpression
;

ArithmeticExpression returns Expression:
	{PostIncrement} value = [Variable] '++' |
	{PostDecrement} value = [Variable] '--' |
	{PreIncrement} '++' value = [Variable] |
	{PreDecrement} '--' value = [Variable] |
	'(' Or ')' | // AdditionSubtraction
	VariableRef |
	IntVal |
	DoubleVal |
	FunctionCall
;

VariableRef: 
	value = [Variable]
;

BoolVal:
	value = BOOL
;

IntVal:
	value=INT
;

DoubleVal:
	value=DOUBLE
;
      
	
//-----------------------------------------------------------
enum Type:
	int | double | bool 
;

enum Skeleton:
	map | mapInPlace | mapIndex | mapIndexInPlace | fold | foldIndex | gather
;

BooleanOperator:
	OP_BOOL_LT | OP_BOOL_LTE | OP_BOOL_EQUALS | OP_BOOL_GTE | OP_BOOL_GT
;

OP_BOOL_LT:
	'<'
;

OP_BOOL_LTE:
	'<='
;

OP_BOOL_EQUALS:
	'=='
;

OP_BOOL_GTE:
	'>='
;

OP_BOOL_GT:
	'>'
;

OP_MATH_PLUS:
	'+'
;

OP_MATH_MINUS:
	'-'
;

OP_MATH_MULT:
	'*'
;

OP_MATH_DIV:
	'/'
;

OP_CONDITION_AND:
	'&&'
;

OP_CONDITION_OR:
	'||'
;

OP_CONDITION_NOT:
	'!'
;

//-----------------------------------------------------------
DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
BOOL returns ecore::EBoolean:
	'true' | 'false'
;