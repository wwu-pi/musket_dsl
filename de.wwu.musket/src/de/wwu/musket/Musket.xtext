grammar de.wwu.musket.Musket with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate musket "http://www.wwu.de/musket/Musket"

Model:
	functions+=Function*
	data+=Data*
	logic=LogicBlock
;
	
//-----------------------------------------------------------
Function:
	returnType=Type name=ID '(' (params+=ParameterDef (',' params+=ParameterDef)*)? ')' '{'
		(statement+=Statement ';')*
	'}'
;
	
ParameterDef:
	type=Type var=Variable
;

//-----------------------------------------------------------	
Data:
	Array;

Array:
	{IntArray} 'int' var=Variable '[' size=INT ']' ('=' '{' values+=INT (',' values+=INT)* '}')? ';' |
	{DoubleArray} 'double' var=Variable '[' size=INT ']' ('=' '{' values+=DOUBLE (',' values+=DOUBLE)* '}')? ';' | 
	{BoolArray} 'bool' var=Variable '[' size=BOOL ']' ('=' '{' values+=BOOL (',' values+=BOOL)* '}')? ';'
;

Variable:
	name=ID
;
	
//-----------------------------------------------------------
LogicBlock:
	'main' '{' content+=Logic+ '}'
;

Logic:
	ControlStructure | MusketStatement;
	
ControlStructure:
	ForLoop | IfClause;
	
ForLoop:
	'for' '(' (init=Assignment)? ';' (condition=CompareExpression)? ';' (increment=ArithmeticExpression)? ')' '{'
		statements+=MusketStatement+
		//TODO break/continue
	'}'
;

IfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=MusketStatement+
	'}'
;

MusketStatement:
	{MusketStatement} (var=[Variable] '=')? (obj=[Variable] '.')? function=Skeleton '(' param=Parameter ')' ';' |
	Assignment ';'
;

Parameter:
	{FunctionCall} value=[Function] '(' param=Parameter ')' | //TODO multiple params
	VariableRef |
	IntVal |
	DoubleVal |
	BoolVal
;

Statement:
	Assignment |
	ReturnStatement
;

Assignment:
	var=[Variable] '=' value=Expression
;

ReturnStatement:
	'return' Expression
;

// Expression tree
Expression:
	CompareExpression // any boolean or arithmetic expression 
;

// Boolean expressions
CompareExpression returns Expression: // Top-level boolean expression
	Condition {CompareExpression.eqLeft=current} (op = BooleanOperator eqRight = Condition)?
;

Condition returns Expression:
	Or
;

Or returns Expression:
	And ({Or.leftExpression=current} OP_CONDITION_OR rightExpression=And)*
;

And returns Expression:
	BooleanExpression ({And.leftExpression=current} OP_CONDITION_AND rightExpression=BooleanExpression)*
;

BooleanExpression returns Expression:
	{Not} OP_CONDITION_NOT expression = BooleanExpression |
	BoolVal |
	AdditionSubtraction
;

// Arithmetic expressions
AdditionSubtraction returns Expression: // Top-Level arithmetic expression
	=> MultiplicationDivision ({Addition.left=current} OP_MATH_PLUS right=MultiplicationDivision)* |
	MultiplicationDivision ({Subtraction.left=current} OP_MATH_MINUS right=MultiplicationDivision)*
;

MultiplicationDivision returns Expression:
	=> ArithmeticExpression ({Multiplication.left=current} OP_MATH_MULT right=ArithmeticExpression)* |
	ArithmeticExpression ({Division.left=current} OP_MATH_DIV right=ArithmeticExpression)*
;

ArithmeticExpression returns Expression:
	{IncrementOperation} value = [Variable] '++' |
	{DecrementOperation} value = [Variable] '--' |
	'(' Or ')' | // AdditionSubtraction
	VariableRef |
	IntVal |
	DoubleVal
;

VariableRef: 
	value = [Variable]
;

BoolVal:
	value = BOOL
;

IntVal:
	value=INT
;

DoubleVal:
	value=DOUBLE
;
      
	
//-----------------------------------------------------------
enum Type:
	int | double | bool 
;

enum Skeleton:
	map | mapInPlace | mapIndex | mapIndexInPlace | fold | foldIndex | gather
;

BooleanOperator:
	OP_BOOL_LT | OP_BOOL_LTE | OP_BOOL_EQUALS | OP_BOOL_GTE | OP_BOOL_GT
;

OP_BOOL_LT:
	'<'
;

OP_BOOL_LTE:
	'<='
;

OP_BOOL_EQUALS:
	'=='
;

OP_BOOL_GTE:
	'>='
;

OP_BOOL_GT:
	'>'
;

OP_MATH_PLUS:
	'+'
;

OP_MATH_MINUS:
	'-'
;

OP_MATH_MULT:
	'*'
;

OP_MATH_DIV:
	'/'
;

OP_CONDITION_AND:
	'&&'
;

OP_CONDITION_OR:
	'||'
;

OP_CONDITION_NOT:
	'!'
;

//-----------------------------------------------------------
DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
BOOL returns ecore::EBoolean:
	'true' | 'false'
;