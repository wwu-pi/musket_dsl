grammar de.wwu.musket.Musket with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate musket "http://www.wwu.de/musket/Musket"

Model:
	config=ConfigBlock
	includes+=Include*
	data+=Data*
	functions+=Function*
	logic=LogicBlock
;

//-----------------------------------------------------------
Include:
	'#include' name=HEADERFILE
;

//-----------------------------------------------------------
ConfigBlock:
	('#config' 'PLATFORM' (platformCPU?='CPU' & platformGPU?='GPU')) &
	('#config' 'PROCESSES' processes=INT)
;

//-----------------------------------------------------------	
Data:
	ArrayDef ';' | VariableDef ';' | Const ';'
;

ArrayDef:
	{IntArray} 'array' '<' 'int' ',' size=INT ',' distributionMode=DistributionMode '>' var=Variable ('=' '{' values+=INT (',' values+=INT)* '}')? |
	{DoubleArray} 'array' '<' 'double' ',' size=INT ',' distributionMode=DistributionMode '>' var=Variable ('=' ('{' values+=DOUBLE (',' values+=DOUBLE)* '}' | functionRef=FunctionCall))? | 
	{BoolArray} 'array' '<' 'bool' ',' size=INT ',' distributionMode=DistributionMode '>' var=Variable ('=' ('{' values+=BOOL (',' values+=BOOL)* '}' | functionRef=FunctionCall))?
;

Variable:
	name=ID
;

VariableDef:
	{IntVariable} 'int' var=Variable ('=' (=> initValue=INT | initExpression=Expression))? |
	{DoubleVariable} 'double' var=Variable ('=' (=> initValue=DOUBLE | initExpression=Expression))? | 
	{BoolVariable} 'bool' var=Variable ('=' (=> initValue=BOOL | initExpression=Expression))?
;

Const:
	{IntConst} 'const' 'int' var=Variable '=' value=INT |
	{DoubleConst} 'const' 'double' var=Variable '=' value=DOUBLE | 
	{BoolConst} 'const' 'bool' var=Variable '=' values=BOOL
;
	
//-----------------------------------------------------------
Function:
	returnType=Type name=ID '(' (params+=ParameterDef (',' params+=ParameterDef)*)? ')' '{'
		(statement+=FunctionStatement)*
	'}'
;

FunctionStatement:
	ControlStructure | Statement ';'
;

ControlStructure:
	ForLoop | IfClause;
	
ForLoop:
	ConditionalForLoop | IteratorForLoop
;

ConditionalForLoop:
	{ConditionalForLoop} 
	'for' '(' (init=VariableDef)? ';' (condition=CompareExpression)? ';' (increment=ArithmeticExpression)? ')'
	//TODO break/continue 
	( '{' statements+=FunctionStatement* '}' | => statements+=FunctionStatement?)
;

IteratorForLoop:
	'for' '(' iter=ParameterDef ':' dataStructure=[Variable] ')'
	//TODO break/continue
	( '{' statements+=FunctionStatement+ '}' | => statements+=FunctionStatement?)
;

IfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=FunctionStatement+
	'}'
;
	
ParameterDef:
	type=Type var=Variable
;
	
//-----------------------------------------------------------
LogicBlock:
	'main' '{' content+=MusketStatement+ '}'
;

MusketStatement:
	MusketControlStructure | BasicMusketStatement ';'
;
	
MusketControlStructure:
	MusketForLoop | MusketIfClause;
	
MusketForLoop:
	MusketConditionalForLoop | MusketIteratorForLoop
;

MusketConditionalForLoop:
	{MusketConditionalForLoop} 
	'for' '(' (init=VariableDef)? ';' (condition=CompareExpression)? ';' (increment=ArithmeticExpression)? ')'
	//TODO break/continue 
	( '{' statements+=MusketStatement* '}' | => statements+=MusketStatement?)
;

MusketIteratorForLoop:
	'for' '(' iter=ParameterDef ':' dataStructure=[Variable] ')'
	//TODO break/continue
	( '{' statements+=MusketStatement+ '}' | => statements+=MusketStatement?)
;

MusketIfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=MusketStatement+
	'}'
;

BasicMusketStatement:
	{SkeletonStatement} (var=[Variable] '=')? (obj=[Variable] '.')? function=Skeleton '(' param=Parameter ')' |
	Assignment |
	FunctionCall
;

Parameter:
	FunctionCall |
	VariableRef |
	IntVal |
	DoubleVal |
	BoolVal
;

Statement:
	Assignment |
	ReturnStatement |
	VariableDef |
	FunctionCall
;

Assignment:
	{VariableAssignment} var=[Variable] '=' value=Expression |
	{ArrayAssignment} var=[Variable] '[' index=INT ']' '=' value=Expression |
	{IncrementAssignment} var=[Variable] '+=' value=Expression |
	{DecrementAssignment} var=[Variable] '-=' value=Expression |
	{MultiplyAssignment} var=[Variable] '*=' value=Expression |
	{DivideAssignment} var=[Variable] '/=' value=Expression
;

ReturnStatement:
	'return' Expression
;

FunctionCall:
	{InternalFunctionCall} value=[Function] '(' (params+=Parameter (',' params+=Parameter)*)? ')' |
	{StandardFunctionCall} value=StandardFunctionName '(' (params+=Parameter (',' params+=Parameter)*)? ')' |
	{ExternalFunctionCall} namespace=ID '::' function=FunctionID '(' (params+=Parameter (',' params+=Parameter)*)? ')'
;

enum StandardFunctionName: // Whitelisting allowed function names from http://www.cplusplus.com/reference/
	// stdlib
	atof | atoi | atol | atoll | strtod | strtof | strtol | strtold | strtoll | strtoul | strtoull |
	rand | srand | 
	calloc | free | mallow | realloc | 
	abort | atexit | at_quick_exit | exit | getenv | quick_exit | system | 
	bsearch | qsort |
	abs | div | labs | ldiv | llabs | lldiv |
	mblen | mbtowc | wctomb | mbstowcs | wcstombs |
	// stdio
	remove | rename | tmpfile | tmpnam |
	fclose | fflush | fopen | freopen | setbuf | setvbuf |
	fprintf | fscanf | printf | scanf | snprintf | sprintf | sscanf | vfprintf | vfscanf | vprintf | vscanf | vsnprintf | vsprintf | vsscanf | 
	fgetc | fgets | fputc | fputs | getc | getchar | gets | putc | putchar | puts | ungetc |
	fread | fwrite | 
	fgetpos | fseek | fsetpos | ftell | rewind |
	clearerr | feof | ferror | perror |
	// math
	cos | sin | tan | acos | asin | atan | atan2 |
	cosh | sinh | tanh | acosh | asinh | atanh | 
	exp | frexp | ldexp | log | log10 | modf | exp2 | expm1 | ilogb | log1p | log2 | logb | scalbn | scalbln | 
	pow | sqrt | cbrt | hypot | 
	erf | erfc | tgamma | lgamma | 
	ceil | floor | fmod | trunc | round | lround | llround | rint | lrint | llrint | nearbyint | remainder | remquo | 
	copysign | nan | nextafter | nexttoward | 
	fdim | fmax | fmin | 
	fabs | fma | 
	fpclassify | isfinite | isinf | isnan | isnormal | signbit | 
	isgreater | isgreaterequal | isless | islessequal | islessgreater | isunordered |
	// string
	memcpy | memmove | strcpy | strncpy | 
	strcat | strncat | 
	memcmp | strcmp | strcoll | strncmp | strxfrm | 
	memchr | strchr | strcspn | strpbrk | strrchr | strspn | strstr | strtok | 
	memset | strerror | strlen 
;

// Expression tree
Expression:
	CompareExpression // any boolean or arithmetic expression 
;

// Boolean expressions
CompareExpression returns Expression: // Top-level boolean expression
	Condition {CompareExpression.eqLeft=current} (op = BooleanOperator eqRight = Condition)?
;

Condition returns Expression:
	Or
;

Or returns Expression:
	And ({Or.leftExpression=current} OP_CONDITION_OR rightExpression=And)*
;

And returns Expression:
	BooleanExpression ({And.leftExpression=current} OP_CONDITION_AND rightExpression=BooleanExpression)*
;

BooleanExpression returns Expression:
	{Not} OP_CONDITION_NOT expression = BooleanExpression |
	BoolVal |
	AdditionSubtraction
;

// Arithmetic expressions
AdditionSubtraction returns Expression: // Top-Level arithmetic expression
	=> MultiplicationDivision ({Addition.left=current} OP_MATH_PLUS right=MultiplicationDivision)* |
	MultiplicationDivision ({Subtraction.left=current} OP_MATH_MINUS right=MultiplicationDivision)*
;

MultiplicationDivision returns Expression:
	=> PrefixedExpression ({Multiplication.left=current} OP_MATH_MULT right=PrefixedExpression)* |
	PrefixedExpression ({Division.left=current} OP_MATH_DIV right=PrefixedExpression)*
;

PrefixedExpression returns Expression:
	{SignedArithmetic} '-' expression=ArithmeticExpression |
	ArithmeticExpression
;

ArithmeticExpression returns Expression:
	{PostIncrement} value = [Variable] '++' |
	{PostDecrement} value = [Variable] '--' |
	{PreIncrement} '++' value = [Variable] |
	{PreDecrement} '--' value = [Variable] |
	'(' Or ')' | // AdditionSubtraction
	VariableRef |
	IntVal |
	DoubleVal |
	FunctionCall
;

VariableRef: 
	value = [Variable]
;

BoolVal:
	value = BOOL
;

IntVal:
	value=INT
;

DoubleVal:
	value=DOUBLE
;
      
	
//-----------------------------------------------------------
enum DistributionMode:
	copy | dist | rowDist | columnDist
;

enum Type:
	int | double | bool 
;

enum Skeleton:
	map | mapInPlace | mapIndex | mapIndexInPlace | fold | foldIndex | gather
;

BooleanOperator:
	OP_BOOL_LT | OP_BOOL_LTE | OP_BOOL_EQUALS | OP_BOOL_GTE | OP_BOOL_GT
;

OP_BOOL_LT:
	'<'
;

OP_BOOL_LTE:
	'<='
;

OP_BOOL_EQUALS:
	'=='
;

OP_BOOL_GTE:
	'>='
;

OP_BOOL_GT:
	'>'
;

OP_MATH_PLUS:
	'+'
;

OP_MATH_MINUS:
	'-'
;

OP_MATH_MULT:
	'*'
;

OP_MATH_DIV:
	'/'
;

OP_CONDITION_AND:
	'&&'
;

OP_CONDITION_OR:
	'||'
;

OP_CONDITION_NOT:
	'!'
;

//-----------------------------------------------------------
DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
BOOL returns ecore::EBoolean:
	'true' | 'false'
;

HEADERFILE returns ecore::EString:
	ID '.h'
;

FunctionID: ID | FunctionWhitelist;

FunctionWhitelist: 
	// stdlib
	'atof' | 'atoi' | 'atol' | 'atoll' | 'strtod' | 'strtof' | 'strtol' | 'strtold' | 'strtoll' | 'strtoul' | 'strtoull' |
	'rand' | 'srand' |
	'calloc' | 'free' | 'mallow' | 'realloc' |
	'abort' | 'atexit' | 'at_quick_exit' | 'exit' | 'getenv' | 'quick_exit' | 'system' |
	'bsearch' | 'qsort' |
	'abs' | 'div' | 'labs' | 'ldiv' | 'llabs' | 'lldiv' |
	'mblen' | 'mbtowc' | 'wctomb' | 'mbstowcs' | 'wcstombs' |
	// stdio
	'remove' | 'rename' | 'tmpfile' | 'tmpnam' |
	'fclose' | 'fflush' | 'fopen' | 'freopen' | 'setbuf' | 'setvbuf' |
	'fprintf' | 'fscanf' | 'printf' | 'scanf' | 'snprintf' | 'sprintf' | 'sscanf' | 'vfprintf' | 'vfscanf' | 'vprintf' | 'vscanf' | 'vsnprintf' | 'vsprintf' | 'vsscanf' |
	'fgetc' | 'fgets' | 'fputc' | 'fputs' | 'getc' | 'getchar' | 'gets' | 'putc' | 'putchar' | 'puts' | 'ungetc' |
	'fread' | 'fwrite' |
	'fgetpos' | 'fseek' | 'fsetpos' | 'ftell' | 'rewind' |
	'clearerr' | 'feof' | 'ferror' | 'perror' |
	// math
	'cos' | 'sin' | 'tan' | 'acos' | 'asin' | 'atan' | 'atan2' |
	'cosh' | 'sinh' | 'tanh' | 'acosh' | 'asinh' | 'atanh' |
	'exp' | 'frexp' | 'ldexp' | 'log' | 'log10' | 'modf' | 'exp2' | 'expm1' | 'ilogb' | 'log1p' | 'log2' | 'logb' | 'scalbn' | 'scalbln' |
	'pow' | 'sqrt' | 'cbrt' | 'hypot' |
	'erf' | 'erfc' | 'tgamma' | 'lgamma' |
	'ceil' | 'floor' | 'fmod' | 'trunc' | 'round' | 'lround' | 'llround' | 'rint' | 'lrint' | 'llrint' | 'nearbyint' | 'remainder' | 'remquo' |
	'copysign' | 'nan' | 'nextafter' | 'nexttoward' |
	'fdim' | 'fmax' | 'fmin' |
	'fabs' | 'fma' |
	'fpclassify' | 'isfinite' | 'isinf' | 'isnan' | 'isnormal' | 'signbit' |
	'isgreater' | 'isgreaterequal' | 'isless' | 'islessequal' | 'islessgreater' | 'isunordered' |
	// string
	'memcpy' | 'memmove' | 'strcpy' | 'strncpy' |
	'strcat' | 'strncat' |
	'memcmp' | 'strcmp' | 'strcoll' | 'strncmp' | 'strxfrm' |
	'memchr' | 'strchr' | 'strcspn' | 'strpbrk' | 'strrchr' | 'strspn' | 'strstr' | 'strtok' |
	'memset' | 'strerror' | 'strlen'
;