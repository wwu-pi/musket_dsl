grammar de.wwu.musket.Musket with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate musket "http://www.wwu.de/musket/Musket"

Model:
	functions+=Function*
	data+=Data*
	logic=LogicBlock
;
	
//-----------------------------------------------------------
Function:
	returnType=Type name=ID '(' (params+=ParameterDef (',' params+=ParameterDef)*)? ')' '{'
		statement=STRING //TODO
	'}'
;
	
ParameterDef:
	type=Type name=ID
;

//-----------------------------------------------------------	
Data:
	Array;

Array:
	{IntArray} 'int' var=Variable '[' size=INT ']' ('=' '{' values+=INT (',' values+=INT)* '}')? ';' |
	{DoubleArray} 'double' var=Variable '[' size=INT ']' ('=' '{' values+=DOUBLE (',' values+=DOUBLE)* '}')? ';' | 
	{BoolArray} 'bool' var=Variable '[' size=BOOL ']' ('=' '{' values+=BOOL (',' values+=BOOL)* '}')? ';'
;

Variable:
	name=ID
;
	
//-----------------------------------------------------------
LogicBlock:
	'main' '{' content+=Logic+ '}'
;

Logic:
	ControlStructure | MusketStatement;
	
ControlStructure:
	ForLoop | IfClause;
	
ForLoop:
	'for' '(' init=InitStatement ';' condition=CompareExpression ';' increment=ArithmeticExpression ')' '{'
		statements+=MusketStatement+
	'}'
;

InitStatement:
	(var=[Variable] '=')? value=INT
;

IfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=MusketStatement+
	'}'
;

MusketStatement:
	{MusketStatement} (var=[Variable] '=')? (obj=[Variable] '.')? function=Skeleton '(' param=Parameter ')' ';'
;

Parameter:
	{FunctionCall} value=[Function] '(' param=Parameter ')' | //TODO multiple params
	{VariableRef} value=[Variable] |
	{IntVal} value = INT |
	{DoubleVal} value = DOUBLE |
	{BoolVal} value = BOOL
;

// Boolean expressions
CompareExpression returns BooleanExpression:
	Condition {CompareExpression.eqLeft=current} (op = BooleanOperator eqRight = Condition)?
;

Condition returns BooleanExpression:
	Or
;

Or returns BooleanExpression:
	And ({Or.leftExpression=current} OP_CONDITION_OR rightExpression=And)*
;

And returns BooleanExpression:
	BooleanExpression ({And.leftExpression=current} OP_CONDITION_AND rightExpression=BooleanExpression)*
;

BooleanExpression:
	('(' Or ')') |
	{Not} OP_CONDITION_NOT expression = BooleanExpression |
	{BooleanValue} value = BOOL |
	{VariableValue} value = [Variable]
;

ArithmeticExpression:
	// TODO some more
	{IncrementOperation} '++' |
	{DecrementOperation} '--' 
;
	
//-----------------------------------------------------------
enum Type:
	int | double | bool 
;

enum Skeleton:
	map | mapInPlace | mapIndex | mapIndexInPlace | fold | foldIndex | gather
;

BooleanOperator:
	OP_BOOL_LT | OP_BOOL_LTE | OP_BOOL_EQUALS | OP_BOOL_GTE | OP_BOOL_GT | OP_BOOL_GT
;

OP_BOOL_LT:
	'<'
;

OP_BOOL_LTE:
	'<='
;

OP_BOOL_EQUALS:
	'='
;

OP_BOOL_GTE:
	'>='
;

OP_BOOL_GT:
	'>'
;

OP_MATH_PLUS:
	'+'
;

OP_MATH_MINUS:
	'-'
;

OP_MATH_MULT:
	'*'
;

OP_MATH_DIV:
	'/'
;

OP_CONDITION_AND:
	'&&'
;

OP_CONDITION_OR:
	'||'
;

OP_CONDITION_NOT:
	'!'
;

//-----------------------------------------------------------
DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
BOOL returns ecore::EBoolean:
	'true' | 'false'
;