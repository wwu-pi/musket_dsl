grammar de.wwu.musket.Musket with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate musket "http://www.wwu.de/musket/Musket"

Model:
	config=ConfigBlock
	includes+=Include*
	data+=MusketObject*
	functions+=RegularFunction*
	main=MainBlock
;

//-----------------------------------------------------------
Include:
	'#include' name=HEADERFILE
;

//-----------------------------------------------------------
ConfigBlock:
	('#config' 'PLATFORM' ((platformSEQ?='SEQ')? & (platformCPU?='CPU')? & (platformGPU?='GPU')?)) &
	('#config' 'PROCESSES' processes=INT) &
	('#config' 'CORES' cores=INT)?	&
	('#config' 'MODE' mode=Mode)?
;

enum Mode:
	release | debug
;

//-----------------------------------------------------------	

ReferableObject:
	MusketObject | Parameter
;

MusketObject:
	Object | Struct
;

Object:
	CollectionObject | IndividualObject;
	
CollectionObject:
	Array ';' | Matrix ';';
	
IndividualObject:
	MusketVariable ';' | Constant ';'
;

Array:
	{IntArray} 'array' '<' 'int' ',' size=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' values+=INT (',' values+=INT)* '}')? |
	{DoubleArray} 'array' '<' 'double' ',' size=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' values+=DOUBLE (',' values+=DOUBLE)* '}')? | 
	{BoolArray} 'array' '<' 'bool' ',' size=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' values+=BOOL (',' values+=BOOL)* '}')? |
	{StructArray} 'array' '<' type=[Struct] ',' size=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' '}')?
;

Matrix:
	{IntMatrix} 'matrix' '<' 'int' ',' rows=INT ',' cols=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' values+=INT (',' values+=INT)* '}')? |
	{DoubleMatrix} 'matrix' '<' 'double' ',' rows=INT ',' cols=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' values+=DOUBLE (',' values+=DOUBLE)* '}')? | 
	{BoolMatrix} 'matrix' '<' 'bool' ',' rows=INT ',' cols=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' values+=BOOL (',' values+=BOOL)* '}')? |
	{StructMatrix} 'matrix' '<' type=[Struct] ',' rows=INT ',' cols=INT ',' distributionMode=DistributionMode '>' name=ID ('=' '{' '}')?
;


Variable:
	IntVariable | DoubleVariable | BoolVariable | StructVariable
;

IntVariable:
	'int' name=ID ('=' initExpression=Expression)?
;

DoubleVariable:
	'double' name=ID ('=' initExpression=Expression)?
;

BoolVariable:
	'bool' name=ID ('=' initExpression=Expression)?
;

StructVariable:
	type=[Struct] name=ID ('=' initExpression=Expression)?
;


MusketVariable:
	MusketIntVariable | MusketDoubleVariable | MusketBoolVariable | Variable
;

MusketIntVariable:
	'int' name=ID '=' initExpression=SkeletonExpression
;

MusketDoubleVariable:
	'double' name=ID '=' initExpression=SkeletonExpression
;

MusketBoolVariable:
	'bool' name=ID '=' initExpression=SkeletonExpression
;

Constant:
	{IntConstant} 'const' 'int' name=ID '=' value=INT |
	{DoubleConstant} 'const' 'double' name=ID '=' value=DOUBLE | 
	{BoolConstant} 'const' 'bool' name=ID '=' value=BOOL
;
	
// TODO Validate: Array/Matrix in structs must be copy-distributed
// TODO Validate: No constants in structs
Struct:
	'struct' name=ID '{'
		attributes+=Object*
	'}' ';'
;
	
//-----------------------------------------------------------
// TODO validate parameter names are unique
// TODO validate new variables do not conflict with parameters/global names
Function:
	RegularFunction | LambdaFunction
;

RegularFunction:
	(returnType=[Struct] | returnTypePrimitive=Type) name=ID '(' (params+=Parameter (',' params+=Parameter)*)? ')' '{'
		(statement+=FunctionStatement)*
	'}'
;

LambdaFunction:
	'(' (params+=Parameter (',' params+=Parameter)*)? ')' '->' (returnType=[Struct] | returnTypePrimitive=Type) '{'
		(statement+=FunctionStatement)*
	'}'
;

FunctionStatement:
	ControlStructure | Statement ';'
;

ControlStructure:
	ForLoop | IfClause;
	
ForLoop:
	ConditionalForLoop | IteratorForLoop
;

ConditionalForLoop:
	{ConditionalForLoop} 
	'for' '(' (init=Variable)? ';' (condition=CompareExpression)? ';' (increment=ArithmeticExpression)? ')'
	//TODO break/continue 
	( '{' statements+=FunctionStatement* '}' | => statements+=FunctionStatement?)
;

IteratorForLoop:
	'for' '(' iter=Parameter ':' dataStructure=[CollectionObjectOrParam] ')'
	//TODO break/continue
	( '{' statements+=FunctionStatement+ '}' | => statements+=FunctionStatement?)
;

IfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=FunctionStatement+
	'}' ('else' '{'
		elseStatements+=FunctionStatement+
	'}')?
;

CollectionObjectOrParam:
	CollectionObject | CollectionParameter
;
	
Parameter:
	CollectionParameter | IndividualParameter
;

CollectionParameter:
	{IntArrayParameter} 'array' '<' 'int' ',' distributionMode=DistributionMode '>' name=ID |
	{DoubleArrayParameter} 'array' '<' 'double' ',' distributionMode=DistributionMode '>' name=ID | 
	{BoolArrayParameter} 'array' '<' 'bool' ',' distributionMode=DistributionMode '>' name=ID |
	{StructArrayParameter} 'array' '<' type=[Struct] ',' distributionMode=DistributionMode '>' name=ID |
	{IntMatrixParameter} 'matrix' '<' 'int' ',' distributionMode=DistributionMode '>' name=ID |
	{DoubleMatrixParameter} 'matrix' '<' 'double' ',' distributionMode=DistributionMode '>' name=ID | 
	{BoolMatrixParameter} 'matrix' '<' 'bool' ',' distributionMode=DistributionMode '>' name=ID |
	{StructMatrixParameter} 'matrix' '<' type=[Struct] ',' distributionMode=DistributionMode '>' name=ID
;

IndividualParameter:
	{IntParameter} 'int' name=ID |
	{DoubleParameter} 'double' name=ID | 
	{BoolParameter} 'bool' name=ID |
	{StructParameter} type=[Struct] name=ID
;
	
//-----------------------------------------------------------
MainBlock:
	'main' '{' content+=MainFunctionStatement+ '}'
;

MainFunctionStatement:
	MusketControlStructure | MusketStatement ';'
;
	
MusketControlStructure:
	MusketForLoop | MusketIfClause;
	
MusketForLoop:
	MusketConditionalForLoop | MusketIteratorForLoop
;

MusketConditionalForLoop:
	{MusketConditionalForLoop} 
	'for' '(' (init=Variable)? ';' (condition=CompareExpression)? ';' (increment=ArithmeticExpression)? ')'
	//TODO break/continue 
	( '{' statements+=MainFunctionStatement* '}' | => statements+=MainFunctionStatement?)
;

MusketIteratorForLoop:
	'for' '(' iter=Parameter ':' dataStructure=[CollectionObject] ')'
	//TODO break/continue
	( '{' statements+=MainFunctionStatement+ '}' | => statements+=MainFunctionStatement?)
;

MusketIfClause:
	'if' '(' condition=CompareExpression ')' '{'
		statements+=MainFunctionStatement+
	'}' ('else' '{'
		elseStatements+=MainFunctionStatement+
	'}')?
;

MusketExpression:
	SkeletonExpression |
	Expression
;

SkeletonExpression:
	obj=[CollectionObject] '.' skeleton=Skeleton
;

Skeleton:
	{MapSkeleton} 'map' ('<' options+=MapOption (',' options+=MapOption)* '>')? '(' param=SkeletonParameterInput ')' |
	{MapInPlaceSkeleton} 'mapInPlace' '(' param=SkeletonParameterInput ')' |
	{MapIndexSkeleton} 'mapIndex' '(' param=SkeletonParameterInput ')' |
	{MapIndexInPlaceSkeleton} 'mapIndexInPlace' '(' param=SkeletonParameterInput ')' |
	{MapLocalIndexInPlaceSkeleton} 'mapLocalIndexInPlace' '(' param=SkeletonParameterInput ')' |
	{FoldSkeleton} 'fold' ('<' options+=FoldOption (',' options+=FoldOption)* '>')? '(' identity=PrimitiveVal ',' param=SkeletonParameterInput ')' |
	{FoldIndexSkeleton} 'foldIndex' '(' identity=PrimitiveVal ',' param=SkeletonParameterInput ')' |
	{ZipSkeleton} 'zip' ('<' options+=ZipOption (',' options+=ZipOption)* '>')? '(' param=SkeletonParameterInput ')' |
	{ZipInPlaceSkeleton} 'zipInPlace' '(' param=SkeletonParameterInput ')' |
	{ZipIndexSkeleton} 'zipIndex' '(' param=SkeletonParameterInput ')' |
	{GatherSkeleton} 'gather' '(' param=SkeletonParameterInput ')' |
	{RotatePartitionsHorizontallySkeleton} 'rotatePartitionsHorizontally' '(' param=SkeletonParameterInput ')' |
	{RotatePartitionsVerticallySkeleton} 'rotatePartitionsVertically' '(' param=SkeletonParameterInput ')' 
;

enum MapOption:
	index | localIndex | inPlace
;

enum FoldOption:
	index
;

enum ZipOption:
	index | localIndex | inPlace
;

ParameterInput:
	FunctionCall |
	ObjectRef |
	PrimitiveVal
;

SkeletonParameterInput:
	FunctionCall | 
	LambdaFunction
;

Statement:
	Assignment |
	ReturnStatement |
	Variable |
	FunctionCall
;

MusketStatement:
	MusketAssignment | 
	SkeletonExpression |
	MusketVariable |
	FunctionCall
;

// TODO check not to assign to Constants
Assignment:
	var=ObjectRef operator=AssignmentOperator value=Expression
;

MusketAssignment:
	var=ObjectRef OP_ASSIGN_EQUALS value=MusketExpression
;

ObjectRef:
	{CollectionElementRef} value=[CollectionObject] CollectionRef (tail = NestedAttributeRef)? |
	=> value=[ReferableObject] (tail = NestedAttributeRef)?
;

fragment CollectionRef*:
	COLL_GLOBAL_OPEN globalCollectionIndex+=Expression (',' globalCollectionIndex+=Expression)* COLL_GLOBAL_CLOSE | 
	COLL_LOCAL_OPEN localCollectionIndex+=Expression (',' localCollectionIndex+=Expression)* COLL_LOCAL_CLOSE
;

NestedAttributeRef:
	{NestedCollectionElementRef} ('.') ref=[CollectionObject] CollectionRef (tail = NestedAttributeRef)? |
	=> ('.') ref=[ReferableObject] (tail = NestedAttributeRef)?
;

ReturnStatement:
	'return' value=Expression
;

FunctionCall:
	InternalFunctionCall | StandardFunctionCall | ExternalFunctionCall | CollectionFunctionCall | MusketFunctionCall
;

InternalFunctionCall:
	value=[Function] '(' (params+=ParameterInput (',' params+=ParameterInput)*)? ')'
;

StandardFunctionCall:
	value=StandardFunctionName '(' (params+=ParameterInput (',' params+=ParameterInput)*)? ')'
;

ExternalFunctionCall:
	namespace=ID '::' function=FunctionID '(' (params+=ParameterInput (',' params+=ParameterInput)*)? ')'
;

CollectionFunctionCall:
	var=[CollectionObject] '.' function=CollectionFunctionName '(' ')'
;

MusketFunctionCall:
	'mkt::'value=MusketFunctionName '(' (params+=ParameterInput (',' params+=ParameterInput)*)? ')'
;

enum StandardFunctionName: // Whitelisting allowed function names from http://www.cplusplus.com/reference/
	// stdlib
	atof | atoi | atol | atoll | strtod | strtof | strtol | strtold | strtoll | strtoul | strtoull |
	rand | srand | 
	calloc | free | mallow | realloc | 
	abort | atexit | at_quick_exit | exit | getenv | quick_exit | system | 
	bsearch | qsort |
	abs | div | labs | ldiv | llabs | lldiv |
	mblen | mbtowc | wctomb | mbstowcs | wcstombs |
	// stdio
	remove | rename | tmpfile | tmpnam |
	fclose | fflush | fopen | freopen | setbuf | setvbuf |
	fprintf | fscanf | printf | scanf | snprintf | sprintf | sscanf | vfprintf | vfscanf | vprintf | vscanf | vsnprintf | vsprintf | vsscanf | 
	fgetc | fgets | fputc | fputs | getc | getchar | gets | putc | putchar | puts | ungetc |
	fread | fwrite | 
	fgetpos | fseek | fsetpos | ftell | rewind |
	clearerr | feof | ferror | perror |
	// math
	cos | sin | tan | acos | asin | atan | atan2 |
	cosh | sinh | tanh | acosh | asinh | atanh | 
	exp | frexp | ldexp | log | log10 | modf | exp2 | expm1 | ilogb | log1p | log2 | logb | scalbn | scalbln | 
	pow | sqrt | cbrt | hypot | 
	erf | erfc | tgamma | lgamma | 
	ceil | floor | fmod | trunc | round | lround | llround | rint | lrint | llrint | nearbyint | remainder | remquo | 
	copysign | nan | nextafter | nexttoward | 
	fdim | fmax | fmin | 
	fabs | fma | 
	fpclassify | isfinite | isinf | isnan | isnormal | signbit | 
	isgreater | isgreaterequal | isless | islessequal | islessgreater | isunordered |
	// string
	memcpy | memmove | strcpy | strncpy | 
	strcat | strncat | 
	memcmp | strcmp | strcoll | strncmp | strxfrm | 
	memchr | strchr | strcspn | strpbrk | strrchr | strspn | strstr | strtok | 
	memset | strerror | strlen 
;

enum CollectionFunctionName:
	// TODO constraint: rows/colums/~local only for matrices
	size | sizeLocal | show | rows | rowsLocal | columns | columsLocal | blocksInRow | blocksInColumn
;

enum MusketFunctionName:
	print | rand
;

// Expression tree
Expression:
	CompareExpression // any boolean or arithmetic expression 
;

// Boolean expressions
CompareExpression returns Expression: // Top-level boolean expression
	Condition {CompareExpression.eqLeft=current} (op = BooleanOperator eqRight = Condition)?
;

Condition returns Expression:
	Or
;

Or returns Expression:
	And ({Or.leftExpression=current} OP_CONDITION_OR rightExpression=And)*
;

And returns Expression:
	BooleanExpression ({And.leftExpression=current} OP_CONDITION_AND rightExpression=BooleanExpression)*
;

BooleanExpression returns Expression:
	{Not} OP_CONDITION_NOT expression = BooleanExpression |
	BoolVal |
	AdditionSubtraction |
	StructVal
;

// Arithmetic expressions
AdditionSubtraction returns Expression: // Top-Level arithmetic expression
	MultiplicationDivision (({Addition.left=current} OP_MATH_PLUS | {Subtraction.left=current} OP_MATH_MINUS) right=MultiplicationDivision)*
;

MultiplicationDivision returns Expression:
	PrefixedExpression (({Multiplication.left=current} OP_MATH_MULT | {Division.left=current} OP_MATH_DIV | {Modulo.left=current} OP_MATH_MODULO) right=PrefixedExpression)*
;

PrefixedExpression returns Expression:
	{SignedArithmetic} '-' expression=ArithmeticExpression |
	{TypeCast} '(' targetType=Type ')' expression=ArithmeticExpression |
	=> ArithmeticExpression
;

ArithmeticExpression returns Expression:
	{PostIncrement} value = [IndividualObject] '++' |
	{PostDecrement} value = [IndividualObject] '--' |
	{PreIncrement} '++' value = [IndividualObject] |
	{PreDecrement} '--' value = [IndividualObject] |
	'(' Or ')' | // AdditionSubtraction
	ObjectRef |
	IntVal |
	DoubleVal |
	FunctionCall
;

PrimitiveVal:
	BoolVal | IntVal | DoubleVal | StringVal
;

BoolVal:
	value=BOOL
;

IntVal:
	value=INT
;

DoubleVal:
	value=DOUBLE
;
      
StringVal:
	value=STRING
;

StructVal:
	{StructVal} '{' '}'
;

//-----------------------------------------------------------
enum DistributionMode:
	copy | dist | rowDist | columnDist
;

enum Type:
	int | double | bool | string
;

// synthetic extension of Type for non-instantiable types
enum NonPrimitiveType returns Type: 
	intArray | doubleArray | boolArray | stringArray | intMatrix | doubleMatrix | boolMatrix | stringMatrix | struct | structArray | structMatrix
;

AssignmentOperator:
	OP_ASSIGN_EQUALS | OP_ASSIGN_ADD | OP_ASSIGN_SUB | OP_ASSIGN_MULT | OP_ASSIGN_DIV 
;

OP_ASSIGN_EQUALS:
	'='
;

OP_ASSIGN_ADD:
	'+='
;

OP_ASSIGN_SUB:
	'-='
;

OP_ASSIGN_MULT:
	'*='
;

OP_ASSIGN_DIV:
	'/='
;

BooleanOperator:
	OP_BOOL_LT | OP_BOOL_LTE | OP_BOOL_EQUALS | OP_BOOL_UNEQUALS | OP_BOOL_GTE | OP_BOOL_GT
;

OP_BOOL_LT:
	'<'
;

OP_BOOL_LTE:
	'<='
;

OP_BOOL_EQUALS:
	'=='
;

OP_BOOL_UNEQUALS:
	'!='
;

OP_BOOL_GTE:
	'>='
;

OP_BOOL_GT:
	'>'
;

OP_MATH_PLUS:
	'+'
;

OP_MATH_MINUS:
	'-'
;

OP_MATH_MULT:
	'*'
;

OP_MATH_DIV:
	'/'
;

OP_MATH_MODULO:
	'%'
;

OP_CONDITION_AND:
	'&&'
;

OP_CONDITION_OR:
	'||'
;

OP_CONDITION_NOT:
	'!'
;

//-----------------------------------------------------------
DOUBLE returns ecore::EDouble:
	INT '.' INT
;
	
BOOL returns ecore::EBoolean:
	'true' | 'false'
;

HEADERFILE returns ecore::EString:
	ID '.h'
;

FunctionID: ID | FunctionWhitelist;

FunctionWhitelist: 
	// stdlib
	'atof' | 'atoi' | 'atol' | 'atoll' | 'strtod' | 'strtof' | 'strtol' | 'strtold' | 'strtoll' | 'strtoul' | 'strtoull' |
	'rand' | 'srand' |
	'calloc' | 'free' | 'mallow' | 'realloc' |
	'abort' | 'atexit' | 'at_quick_exit' | 'exit' | 'getenv' | 'quick_exit' | 'system' |
	'bsearch' | 'qsort' |
	'abs' | 'div' | 'labs' | 'ldiv' | 'llabs' | 'lldiv' |
	'mblen' | 'mbtowc' | 'wctomb' | 'mbstowcs' | 'wcstombs' |
	// stdio
	'remove' | 'rename' | 'tmpfile' | 'tmpnam' |
	'fclose' | 'fflush' | 'fopen' | 'freopen' | 'setbuf' | 'setvbuf' |
	'fprintf' | 'fscanf' | 'printf' | 'scanf' | 'snprintf' | 'sprintf' | 'sscanf' | 'vfprintf' | 'vfscanf' | 'vprintf' | 'vscanf' | 'vsnprintf' | 'vsprintf' | 'vsscanf' |
	'fgetc' | 'fgets' | 'fputc' | 'fputs' | 'getc' | 'getchar' | 'gets' | 'putc' | 'putchar' | 'puts' | 'ungetc' |
	'fread' | 'fwrite' |
	'fgetpos' | 'fseek' | 'fsetpos' | 'ftell' | 'rewind' |
	'clearerr' | 'feof' | 'ferror' | 'perror' |
	// math
	'cos' | 'sin' | 'tan' | 'acos' | 'asin' | 'atan' | 'atan2' |
	'cosh' | 'sinh' | 'tanh' | 'acosh' | 'asinh' | 'atanh' |
	'exp' | 'frexp' | 'ldexp' | 'log' | 'log10' | 'modf' | 'exp2' | 'expm1' | 'ilogb' | 'log1p' | 'log2' | 'logb' | 'scalbn' | 'scalbln' |
	'pow' | 'sqrt' | 'cbrt' | 'hypot' |
	'erf' | 'erfc' | 'tgamma' | 'lgamma' |
	'ceil' | 'floor' | 'fmod' | 'trunc' | 'round' | 'lround' | 'llround' | 'rint' | 'lrint' | 'llrint' | 'nearbyint' | 'remainder' | 'remquo' |
	'copysign' | 'nan' | 'nextafter' | 'nexttoward' |
	'fdim' | 'fmax' | 'fmin' |
	'fabs' | 'fma' |
	'fpclassify' | 'isfinite' | 'isinf' | 'isnan' | 'isnormal' | 'signbit' |
	'isgreater' | 'isgreaterequal' | 'isless' | 'islessequal' | 'islessgreater' | 'isunordered' |
	// string
	'memcpy' | 'memmove' | 'strcpy' | 'strncpy' |
	'strcat' | 'strncat' |
	'memcmp' | 'strcmp' | 'strcoll' | 'strncmp' | 'strxfrm' |
	'memchr' | 'strchr' | 'strcspn' | 'strpbrk' | 'strrchr' | 'strspn' | 'strstr' | 'strtok' |
	'memset' | 'strerror' | 'strlen'
;

terminal COLL_GLOBAL_OPEN: 
	'['
;

terminal COLL_GLOBAL_CLOSE: 
	']'
;

terminal COLL_LOCAL_OPEN: 
	'[['
;

terminal COLL_LOCAL_CLOSE: 
	']]'
;