/*
 * generated by Xtext 2.11.0
 */
package de.wwu.musket.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import de.wwu.musket.musket.MusketPackage
import de.wwu.musket.musket.ObjectRef
import de.wwu.musket.musket.NestedAttributeRef
import org.eclipse.xtext.scoping.Scopes
import de.wwu.musket.musket.Struct
import org.eclipse.xtext.EcoreUtil2
import de.wwu.musket.musket.StructParameter
import de.wwu.musket.musket.CollectionElementRef

import static extension de.wwu.musket.util.TypeHelper.*
import de.wwu.musket.musket.StructArray
import de.wwu.musket.musket.StructMatrix
import org.eclipse.xtext.scoping.IScope
import de.wwu.musket.musket.ReferableObject

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MusketScopeProvider extends AbstractMusketScopeProvider {

    override getScope(EObject context, EReference reference) {
		// We want to define the Scope for the Element's superElement cross-reference
		if (context instanceof NestedAttributeRef && reference == MusketPackage.eINSTANCE.nestedAttributeRef_Ref) {
			
			val ReferableObject containerElement = 
				if(context.eContainer instanceof ObjectRef) {
					(context.eContainer as ObjectRef).value
				} else if(context.eContainer instanceof NestedAttributeRef) {
					(context.eContainer as NestedAttributeRef).ref
				}
			
			val rootElement = EcoreUtil2.getRootContainer(context)
	            	
            if(containerElement instanceof StructParameter) {
            	val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Struct).filter[struct | struct === containerElement.type].map[struct | struct.attributes].flatten
            	return Scopes.scopeFor(candidates)
            } else if (containerElement instanceof StructArray) {
            	val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Struct).filter[struct | struct === containerElement.type].map[struct | struct.attributes].flatten
            	return Scopes.scopeFor(candidates)
            } else if (containerElement instanceof StructMatrix) {
            	val candidates = EcoreUtil2.getAllContentsOfType(rootElement, Struct).filter[struct | struct === containerElement.type].map[struct | struct.attributes].flatten
            	return Scopes.scopeFor(candidates)
            } else {
            	return IScope::NULLSCOPE;
            }
        }
        return super.getScope(context, reference);
    }
}
