/*
 * generated by Xtext 2.11.0
 */
package de.wwu.musket.scoping

import de.wwu.musket.musket.BoolVariable
import de.wwu.musket.musket.CollectionObject
import de.wwu.musket.musket.DoubleVariable
import de.wwu.musket.musket.IntVariable
import de.wwu.musket.musket.MusketStructVariable
import de.wwu.musket.musket.ObjectRef
import de.wwu.musket.musket.Ref
import de.wwu.musket.musket.ReferableObject
import de.wwu.musket.musket.Struct
import de.wwu.musket.musket.StructArray
import de.wwu.musket.musket.StructMatrix
import de.wwu.musket.musket.StructParameter
import de.wwu.musket.musket.StructVariable
import de.wwu.musket.musket.TailObjectRef
import java.util.Collection
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MusketScopeProvider extends AbstractMusketScopeProvider {

	override getScope(EObject context, EReference reference) {
		if(context instanceof TailObjectRef){
			val container = (context.eContainer as Ref)
			val head = container.value 
			val isCollectionRef = (container.localCollectionIndex?.size > 0 || container.globalCollectionIndex?.size > 0)
			 
			switch (head) {
				MusketStructVariable: return Scopes::scopeFor((head as MusketStructVariable).type.attributes)
				StructVariable: return Scopes::scopeFor((head as StructVariable).type.attributes)
				StructParameter: return Scopes::scopeFor((head as StructParameter).type.attributes)
				StructArray case isCollectionRef: return Scopes::scopeFor((head as StructArray).type.attributes)
				StructMatrix case isCollectionRef: return Scopes::scopeFor((head as StructArray).type.attributes)
				default: return IScope::NULLSCOPE
			}
		} else if(context instanceof ObjectRef){
			return getScopeFromPosition(context) 
		}

		return super.getScope(context, reference);
	}
	
	def getScopeFromPosition(EObject pos){
	 	// Move to top level of nested statements to get function
		var EObject obj = pos
		var Collection<ReferableObject> inScope = newArrayList()
		while(obj !== null) {
			// collect available elements in scope on this level but exclude non-instantiable struct type definition
			// TODO exclude objects after current position
			inScope.addAll(obj.eContents.filter(ReferableObject).filter[!(it instanceof Struct)].toList)
			// Add nested names in multi attributes
			inScope.addAll(obj.eContents.filter(IntVariable).map[it.vars].flatten.toList)
			inScope.addAll(obj.eContents.filter(DoubleVariable).map[it.vars].flatten.toList)
			inScope.addAll(obj.eContents.filter(BoolVariable).map[it.vars].flatten.toList)
			inScope.addAll(obj.eContents.filter(StructVariable).map[it.vars].flatten.toList)
			inScope.addAll(obj.eContents.filter(CollectionObject).map[it.vars].flatten.toList)
			
			obj = obj.eContainer
		} 
		return Scopes.scopeFor(inScope)
	}
}
