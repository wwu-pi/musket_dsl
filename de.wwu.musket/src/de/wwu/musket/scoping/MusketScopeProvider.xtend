/*
 * generated by Xtext 2.11.0
 */
package de.wwu.musket.scoping

import de.wwu.musket.musket.BoolVariable
import de.wwu.musket.musket.CollectionObject
import de.wwu.musket.musket.CollectionParameter
import de.wwu.musket.musket.ConditionalForLoop
import de.wwu.musket.musket.DoubleVariable
import de.wwu.musket.musket.IndividualParameter
import de.wwu.musket.musket.IntVariable
import de.wwu.musket.musket.IteratorForLoop
import de.wwu.musket.musket.MusketConditionalForLoop
import de.wwu.musket.musket.MusketIteratorForLoop
import de.wwu.musket.musket.MusketStructVariable
import de.wwu.musket.musket.ObjectRef
import de.wwu.musket.musket.Ref
import de.wwu.musket.musket.ReferableObject
import de.wwu.musket.musket.Struct
import de.wwu.musket.musket.StructArrayType
import de.wwu.musket.musket.StructMatrixType
import de.wwu.musket.musket.StructType
import de.wwu.musket.musket.StructVariable
import de.wwu.musket.musket.TailObjectRef
import java.util.Collection
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

import static extension de.wwu.musket.util.CollectionHelper.*
import de.wwu.musket.musket.FloatVariable

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MusketScopeProvider extends AbstractMusketScopeProvider {

	override getScope(EObject context, EReference reference) {
		if(context instanceof TailObjectRef){
			val container = (context.eContainer as Ref)
			val head = container.value 
			 
			switch (head) {
				MusketStructVariable: return Scopes::scopeFor((head as MusketStructVariable).type.attributes)
				StructVariable: return Scopes::scopeFor((head as StructVariable).type.attributes)
				CollectionParameter case head.type instanceof StructArrayType: return Scopes::scopeFor((head.type as StructArrayType).type.attributes)
				CollectionParameter case head.type instanceof StructMatrixType: return Scopes::scopeFor((head.type as StructMatrixType).type.attributes)
				IndividualParameter case head.type instanceof StructType: return Scopes::scopeFor((head.type as StructType).type.attributes)  
				CollectionObject case head.type instanceof StructArrayType && container.isCollectionElementRef: return Scopes::scopeFor((head.type as StructArrayType).type.attributes)
				CollectionObject case head.type instanceof StructMatrixType && container.isCollectionElementRef: return Scopes::scopeFor((head.type as StructMatrixType).type.attributes)
				default: return IScope::NULLSCOPE
			}
		} else if(context instanceof ObjectRef){
			return getScopeFromPosition(context) 
		}

		return super.getScope(context, reference);
	}
	
	def getScopeFromPosition(EObject pos){
		// Iteratively move to top level of nested elements while collecting variable names in scope
		var EObject obj = pos
		var Collection<ReferableObject> inScope = newArrayList()
		while(obj.eContainer !== null) {
			val allElements = obj.eContainer.eContents
			val filteredElements = allElements.subList(0, allElements.indexOf(obj)).toList
			
			// collect available elements in scope on this level but exclude non-instantiable struct type definition
			inScope.addAll(filteredElements.filter(ReferableObject).filter[!(it instanceof Struct)].toList)
			
			// Add nested names in multi attributes
			inScope.addAll(filteredElements.filter(IntVariable).map[it.vars].flatten.toList)
			inScope.addAll(filteredElements.filter(DoubleVariable).map[it.vars].flatten.toList)
			inScope.addAll(filteredElements.filter(FloatVariable).map[it.vars].flatten.toList)
			inScope.addAll(filteredElements.filter(BoolVariable).map[it.vars].flatten.toList)
			inScope.addAll(filteredElements.filter(StructVariable).map[it.vars].flatten.toList)
			inScope.addAll(filteredElements.filter(CollectionObject).map[it.vars].flatten.toList)
			
			// Special cases which add variable names to scope
			switch(obj){
				MusketConditionalForLoop: inScope.addAll(obj.init)
				MusketIteratorForLoop: inScope.addAll(obj.iter)
				ConditionalForLoop: inScope.addAll(obj.init)
				IteratorForLoop: inScope.addAll(obj.iter)
			}
			
			obj = obj.eContainer
		}

		return Scopes.scopeFor(inScope)
	}
}
